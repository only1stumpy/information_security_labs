# SHA-256: Криптографическая хеш-функция

## Что такое SHA-256?

**SHA-256** (Secure Hash Algorithm 256-bit) - это криптографическая хеш-функция из семейства SHA-2, разработанная Агентством национальной безопасности США (NSA) и опубликованная Национальным институтом стандартов и технологий (NIST) в 2001 году.

SHA-256 преобразует входное сообщение произвольной длины в фиксированную 256-битную (32-байтовую) хеш-сумму.

## Основные свойства

1. **Детерминированность**: одинаковый вход всегда дает одинаковый выход
2. **Быстрое вычисление**: хеш вычисляется быстро
3. **Эффект лавины**: малейшее изменение входа кардинально меняет хеш
4. **Необратимость**: невозможно восстановить исходное сообщение из хеша
5. **Стойкость к коллизиям**: вычислительно невозможно найти два разных сообщения с одинаковым хешем

## Применение

- Проверка целостности данных
- Цифровые подписи
- Хранение паролей (с солью)
- Blockchain и криптовалюты (Bitcoin использует SHA-256)
- Сертификаты SSL/TLS
- Контрольные суммы файлов

## Алгоритм SHA-256

### Шаг 1: Предобработка сообщения (Preprocessing)

#### 1.1 Конвертация в байты
Сообщение преобразуется в последовательность байтов с использованием UTF-8 кодирования:
- ASCII символы (0-127): 1 байт
- Символы 128-2047: 2 байта
- Символы 2048-65535: 3 байта
- Редкие символы/эмодзи: 4 байта

#### 1.2 Добавление padding (дополнение)
1. Добавляется бит `1` (байт `0x80`)
2. Добавляются нули до тех пор, пока длина не станет 448 mod 512 (или 56 mod 64 байт)
3. Добавляется 64-битное число, представляющее длину исходного сообщения в битах (big-endian)

**Пример для "hello world":**
```
Исходное сообщение: "hello world" (11 байт = 88 бит)
В битах: 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100
         h        e        l        l        o        (space)  w        o        r        l        d

После padding:
01101000 01100101 ... 01100100 10000000 00000000 ... 00000000 00000000 00000000 00000000 00000000 00000000 00000000 01011000
                                ^бит 1   ^нули (до 448 бит)                    ^длина=88 (64 бита)
```

#### 1.3 Разбиение на блоки
Дополненное сообщение разбивается на блоки по 512 бит (16 слов по 32 бита).

### Шаг 2: Инициализация переменных хеша

Используются первые 32 бита дробной части квадратных корней первых 8 простых чисел:

```
h0 = 0x6a09e667  (√2)
h1 = 0xbb67ae85  (√3)
h2 = 0x3c6ef372  (√5)
h3 = 0xa54ff53a  (√7)
h4 = 0x510e527f  (√11)
h5 = 0x9b05688c  (√13)
h6 = 0x1f83d9ab  (√17)
h7 = 0x5be0cd19  (√19)
```

### Шаг 3: Константы раунда

64 константы `k[0..63]` - первые 32 бита дробной части кубических корней первых 64 простых чисел:

```javascript
const k = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, // ∛2, ∛3, ∛5, ∛7
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, // ∛11, ∛13, ∛17, ∛19
  // ... всего 64 константы
];
```

### Шаг 4: Обработка каждого блока

Для каждого 512-битного блока:

#### 4.1 Создание расписания сообщений (Message Schedule)
Создается массив из 64 32-битных слов `w[0..63]`:

```
w[0..15] = текущий блок (16 слов по 32 бита)

Для i от 16 до 63:
  σ0 = ROTR⁷(w[i-15]) ⊕ ROTR¹⁸(w[i-15]) ⊕ SHR³(w[i-15])
  σ1 = ROTR¹⁷(w[i-2])  ⊕ ROTR¹⁹(w[i-2])  ⊕ SHR¹⁰(w[i-2])
  w[i] = w[i-16] + σ0 + w[i-7] + σ1 (mod 2³²)
```

Где:
- `ROTR^n(x)` - циклический сдвиг вправо на n бит
- `SHR^n(x)` - логический сдвиг вправо на n бит (заполнение нулями)
- `⊕` - операция XOR (исключающее ИЛИ)

#### 4.2 Инициализация рабочих переменных
```
a = h0
b = h1
c = h2
d = h3
e = h4
f = h5
g = h6
h = h7
```

#### 4.3 Главный цикл (64 раунда)
Для каждого раунда i от 0 до 63:

```
Σ1 = ROTR⁶(e) ⊕ ROTR¹¹(e) ⊕ ROTR²⁵(e)
Ch = (e AND f) ⊕ (NOT e AND g)           // Choose: если e=1, берем f, иначе g
temp1 = h + Σ1 + Ch + k[i] + w[i]

Σ0 = ROTR²(a) ⊕ ROTR¹³(a) ⊕ ROTR²²(a)
Maj = (a AND b) ⊕ (a AND c) ⊕ (b AND c) // Majority: большинство битов
temp2 = Σ0 + Maj

h = g
g = f
f = e
e = d + temp1
d = c
c = b
b = a
a = temp1 + temp2
```

**Визуализация раунда:**
```
     ┌───┐  ┌───┐  ┌───┐  ┌───┐  ┌───┐  ┌───┐  ┌───┐  ┌───┐
     │ a │  │ b │  │ c │  │ d │  │ e │  │ f │  │ g │  │ h │
     └─┬─┘  └─┬─┘  └─┬─┘  └─┬─┘  └─┬─┘  └─┬─┘  └─┬─┘  └─┬─┘
       │      │      │      │      │      │      │      │
       │      │      │      │      │      │      │      │
      Σ0     │      │      │     Σ1     │      │      │
      Maj    │      │      │     Ch      │      │      │
       │      │      │      │      │      │      │      │
       └──────┴──────┴──────┼──────┴──────┴──────┴──────┘
                            │             + k[i] + w[i]
                            └──────────────────┐
                                               │
       ┌───────────────────────────────────────┘
       │
     ┌─┴─┐  ┌───┐  ┌───┐  ┌───┐  ┌───┐  ┌───┐  ┌───┐  ┌───┐
     │ a'│  │ b'│  │ c'│  │ d'│  │ e'│  │ f'│  │ g'│  │ h'│
     └───┘  └───┘  └───┘  └───┘  └───┘  └───┘  └───┘  └───┘
```

#### 4.4 Обновление хеша
После 64 раундов:
```
h0 = h0 + a (mod 2³²)
h1 = h1 + b (mod 2³²)
h2 = h2 + c (mod 2³²)
h3 = h3 + d (mod 2³²)
h4 = h4 + e (mod 2³²)
h5 = h5 + f (mod 2³²)
h6 = h6 + g (mod 2³²)
h7 = h7 + h (mod 2³²)
```

### Шаг 5: Формирование финального хеша

Финальный 256-битный хеш получается конкатенацией `h0 || h1 || h2 || h3 || h4 || h5 || h6 || h7`:

```
hash = h0.toString(16) + h1.toString(16) + ... + h7.toString(16)
```

## Пример работы

### Входное сообщение: "hello world"

```
1. Конвертация в байты:
   68 65 6c 6c 6f 20 77 6f 72 6c 64

2. Padding:
   68 65 6c 6c 6f 20 77 6f 72 6c 64 80 00 00 ... 00 00 00 00 00 00 00 58
   [11 байт сообщения] [1 бит] [нули до 56 байт] [8 байт длины = 88 бит]

3. Обработка через 64 раунда компрессии

4. Финальный хеш:
   B94D27B9934D3E08A52E52D7DA7DABFAC484EFE37A5380EE9088F7ACE2EFCDE9
```

### Входное сообщение: "hello worlD" (изменена последняя буква)

```
Финальный хеш:
   D7914FE546B684688BB95F4F888A92DFC680603A75F23EB823658031FFF695D1

Полностью другой хеш! (эффект лавины)
```

## Особенности реализации

### Операторы JavaScript

- `>>>` - логический сдвиг вправо без знака (заполнение нулями)
- `<<` - логический сдвиг влево
- `^` - побитовый XOR
- `&` - побитовый AND
- `~` - побитовый NOT
- `|` - побитовый OR
- `>>> 0` - приведение к беззнаковому 32-битному целому

### Циклический сдвиг вправо (ROTR)

```javascript
function rightRotate(value, count) {
  return (value >>> count) | (value << (32 - count));
}
```

**Пример:** `ROTR^3(11010110)`:
```
Исходное:     11010110
Сдвиг >>> 3:  00011010
Сдвиг << 5:   11000000
XOR (|):      11011010
              ^^^     ← биты переместились вправо циклически
```

## Криптографическая стойкость

### Вычислительная сложность

- **Поиск прообраза**: O(2²⁵⁶) операций
- **Поиск второго прообраза**: O(2²⁵⁶) операций
- **Поиск коллизии**: O(2¹²⁸) операций (парадокс дней рождения)

### Почему SHA-256 безопасен?

1. **Необратимость**: Невозможно вычислить обратную функцию из-за необратимых операций (XOR, AND, сложение по модулю)

2. **Лавинный эффект**: Изменение одного бита входа меняет в среднем 50% битов выхода

3. **Нелинейность**: Функции Ch и Maj обеспечивают нелинейные преобразования

4. **Диффузия**: 64 раунда обеспечивают полное перемешивание всех битов

5. **Большое пространство хешей**: 2²⁵⁶ ≈ 10⁷⁷ возможных хешей (больше атомов во Вселенной!)

## Сравнение с другими алгоритмами

| Алгоритм | Размер хеша | Блок | Раунды | Статус |
|----------|-------------|------|--------|--------|
| MD5      | 128 бит     | 512  | 64     | ❌ Уязвим (коллизии найдены) |
| SHA-1    | 160 бит     | 512  | 80     | ⚠️ Устаревший (коллизии найдены) |
| SHA-256  | 256 бит     | 512  | 64     | ✅ Безопасен |
| SHA-512  | 512 бит     | 1024 | 80     | ✅ Безопасен |
| SHA-3    | 224-512 бит | 1600 | 24     | ✅ Безопасен (другой дизайн) |

## Использование в коде

```javascript
// Вызов функции
const result = sha256("hello world");

// Результат:
// Исходное сообщение: hello world
// Двоичное представление: 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100
// SHA-256 хеш-сумма: B94D27B9934D3E08A52E52D7DA7DABFAC484EFE37A5380EE9088F7ACE2EFCDE9
```

## Ограничения

1. **Не шифрование**: SHA-256 - это хеш, а не шифр. Нельзя "расшифровать" хеш обратно
2. **Радужные таблицы**: Для паролей нужна соль (salt) и медленные алгоритмы (bcrypt, Argon2)
3. **Длина**: 256 бит может быть избыточным для некоторых применений (можно использовать SHA-224)

## Тестирование

Проверить корректность реализации можно с помощью известных тестовых векторов:

```
"" (пустая строка)
→ E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855

"abc"
→ BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD

"hello world"
→ B94D27B9934D3E08A52E52D7DA7DABFAC484EFE37A5380EE9088F7ACE2EFCDE9

"Защита информации"
→ 07B88C2B939555213D46B4334E5FA9A90A936C9634173B8A3EC458689B2CD16B
```

## Полезные ссылки

- [FIPS 180-4: Secure Hash Standard](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf) - официальная спецификация
- [RFC 6234: US Secure Hash Algorithms](https://tools.ietf.org/html/rfc6234) - описание алгоритма
- [SHA-256 визуализация](https://sha256algorithm.com/) - интерактивная визуализация алгоритма

## Заключение

SHA-256 - это надежная криптографическая хеш-функция, которая широко используется в современных системах безопасности. Понимание её внутреннего устройства важно для специалистов по информационной безопасности.

**Основные выводы:**
- ✅ Детерминированная и необратимая
- ✅ Стойкая к коллизиям
- ✅ Эффект лавины
- ✅ Широко используется в реальных приложениях
- ✅ Доказанная криптостойкость

---

*Реализация: TypeScript, Next.js 15*
*Лабораторная работа №7 по дисциплине "Защита информации"*
*Вариант 1: Программная реализация без использования библиотек*
